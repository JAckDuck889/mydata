数据结构笔记

第一章：绪论

1：线性关系(1:1) 包含线性表   
   1）结点   1个前驱    1个后继

2：树型(1:n) --> 初始状态： 根root      叶子 leaf

3:  图 n:m  


4：类C   -->  只有子函数，没有主函数

5： C++    输入 cin>>    输出 cout<<
   
    C      输入scanf()   输出 printf()

6: 复数Complex= 实部 real   +   虚部 imag

7: 时间复杂度T(n)=O(n) 
   *****:程序执行次数的最大数量级（指数）: 与系数无关 *****
   ********************************************************


   ****如果执行次数是确定的1个数字 ---》则为常量阶 -->O(1)-->O(n0)   
   1)执行 956次---->常数阶---->O(n0)=O(1)


   2)执行次数与n的大小：线性关系----> 线性阶--->O(n1)=O(n)
     for(i=1;i<=n;i++)   循环执行n次

   3）执行次数为n*n   n*m   :平方线性关系->平方阶->O(n*n)/O(n*m)-->O(n2)
      for(i=1;i<=n;i++)
         for(j=1;j<=n;j++)
          printf(a[i][j])

时间复杂度T(n)=O(n*n)=O(n2)  -->执行次数n*n


第三章：
1：前驱  p->prior    后继 P->next

2: 线性表的插入移动次数
   例如  List={a1,a2........a50......a100} ,在a50之前插入一个b
         则需移动元素的次数（个数）=51

*****推导：在长度为n的线性表中的第i个元素之前插入1个元素
         则需移动（尾元素先移动） 个数为= n-i+1  

3: 顺序表SqList 
   Loc(a i+1) =Loc(a i)+L

   Loc(ai)=Loc(a1)+(i-1)*l   
  
4:单链表 LinkList
   单链表中： 结点Node = 数据域DataNode  +  指针域(P->next) 
   单链表中：除了首尾结点，其他结点都有1个前驱，1个后继
   1）首元结点  第1个结点 ：前面有1个头指针
   2）尾结点的指针域：为空 Null /\  
   3)LNode 单链表结点
   4）单链表 插入  先右后左     s->next=p->next    p->next=s  


   Loc(a5)=Loc(a1)+(5-1)*2
          =100    +8
5:下标定位

3： 127   0 + 127/2

第三章：栈 与队列

1) 栈=堆栈 Stack   FILO   一头堵   底部Bottom   开口 top

2）满栈  top=n     空栈 top=0  

3) push（）进栈     pop()出栈    空栈 top=bottom
   top+1            top-1 

4）Sqstack 顺序栈

5)每匹配一趟，字串都整体后移1位、

6）Array  

7) B=(e)       gethead(B) =e     GetTail(B) =()空表

   D=(A,B,C)   Gethead(D) =A     GetTail(D)=(B,C)

第五章：
1：Tree树  ：无孩 或 1/n个孩子    :子树 

2：Binary Tree  二叉树： 最多2孩


3：树只有1个根root

4： 树的深度   ：含根在内，一共几层   A :root根 

5: Node    儿子数     最大儿子数    leaf:无子结点   

6：root  Lchild   Rchild `1`

针对二叉树 （先中后：对根而言）

1）先序遍历   根 左 右  

2）中序遍历   左 根 右

3) 后序遍历   左 右 根



**********必考题
已知先序，中序，后序中的2个序列，求第3个序列，并画出该二叉树

考试技巧
1）找根
2）分左右子树

哈夫曼树
1）权    结点的数值

2）路径  从根结点到该结点的步数  


3）哈夫曼树构造算法
  1）权小取为叶子
  2）权越大越靠近根
  3）上一层的结点>=下一层结点





例【1.3】【1.4】【1.5】【1.6】【1.7】【1.8】
1.2.2数据结构的概念 逻辑结构和存储结构
P7上面的ADT抽象数据类型名
1.3（4、5、6、7）
P9（1）定义部分
1.4.1算法五个特征（重点）
1.4.2 
1.4.3时间复杂度老师说需要掌握，有可能考计算
1.5小结里面的（1）（2）
案例2.1 案例2.2
P22页线性表的4个特点
2.3线性表主要掌握P22页的getelem listinsert listdelete三个操作（重点）
2.4.1的两个公式，顺序表的定义
2.4.2顺序表初始化的定义
算法2.1 顺序表的取值、查找、插入需要掌握
计算平均时间复杂度需要掌握
2.5.1P30上面的名词解释
图2.8 2.9
单链表的取值、查找、插入、删除要掌握意义
图2.12 2.14
循环列表的概念
后面习题的选择题
第三章
3.3.1 第一段的名词解释 栈又称为先进后出的线性表图3.1（a）（重点）
3.1.2队列的名词解释 先进先出的线性表 图3.2（重点）
P57的基本操作里面的push pop需要重点掌握
顺序栈的定义，三行代码，和名词解释
图3.3acbd重点理解
算法3.1 3.2 3.3（配合上面的图重点理解）
3.4递归P62页中间两段代码需要理解，和C语言的递归一个意义
3.5 enqueue和dequeue 重点掌握
图3.12表格需要理解意义
第四章
P87页串的定义 名词解释，理解意义
P89 strcopy strcompare的标准例如adc<abd，因为d大于c
BF算法P92【算法描述】（必考考点）
图4.4 重点，每匹配一趟，字串都整体后移一位
P99页下面的公式，（必考考点）
4.5广义表
P102倒数第四句广义表的定义，和第一句
P103上面6点 深度就是层次，如图4.14就是4层，圆圈就是子表，方框就是原子
取表头gethead 和 取表尾 （必考）
习题选择题全部和应用题12
第五章
5.1.1树的定义
5.1.2名词解释
二叉树的定义
5.4二叉树性质5点和公式，需要掌握
满二叉树和完全二叉树掌握
遍历二叉树三个操作
先序遍历二叉树
根左右
中序遍历二叉树
左根有
后序遍历二叉树
左右根
掌握三个方法，如已知先序、中序、后序的其中两个，求二叉树的图和第三个序列
P122和图5.5后面的四个序列必须理解学会如何计算（必考）
【例5.1】（必考）和上面一样的
图5.19 图5.21掌握理解
图5.24，掌握理解三个树如何变成旁边的森林，不懂群里问（重点）
P136哈夫曼树的名词解释
图5.25 带权路径长度WPL需要重点掌握
哈夫曼树的构造过程
1、权小的取为树叶
2、权越大越靠近根
3、上一层的结点>=下一层结点 
图5.26 
【例5.2】重点
后面的时间不够老师就没有讲了，自求多福吧






























      